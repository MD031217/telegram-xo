<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Крестики-нолики 5 в ряд</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        
        .game-container {
            display: inline-block;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            max-width: 95vw;
        }
        
        .game-info {
            margin-bottom: 15px;
            font-size: 18px;
            color: #555;
        }
        
        .game-board-container {
            position: relative;
            overflow: auto;
            max-height: 70vh;
            border: 2px solid #333;
            margin: 0 auto;
            background: 
                linear-gradient(90deg, #ccc 1px, transparent 1px),
                linear-gradient(0deg, #ccc 1px, transparent 1px);
            background-size: 40px 40px;
        }
        
        #gameBoard {
            position: relative;
            min-width: 600px;
            min-height: 600px;
        }
        
        .cell {
            width: 40px;
            height: 40px;
            position: absolute;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #ddd;
            box-sizing: border-box;
        }
        
        .cell:hover {
            background-color: rgba(240, 240, 240, 0.9);
        }
        
        .x::before, .x::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 4px;
            background-color: #e74c3c;
            top: 50%;
            left: 10%;
        }
        
        .x::before {
            transform: translateY(-50%) rotate(45deg);
        }
        
        .x::after {
            transform: translateY(-50%) rotate(-45deg);
        }
        
        .o::before {
            content: '';
            position: absolute;
            width: 70%;
            height: 70%;
            border: 4px solid #3498db;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .coordinates {
            font-size: 10px;
            color: #999;
            position: absolute;
            bottom: 2px;
            right: 2px;
        }
        
        .center-marker {
            position: absolute;
            width: 2px;
            height: 2px;
            background: red;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .controls {
            margin-top: 20px;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
        }
        
        button:hover {
            background-color: #27ae60;
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .win-message {
            font-size: 24px;
            font-weight: bold;
            margin-top: 15px;
            color: #e74c3c;
        }
        
        .view-controls {
            margin: 10px 0;
        }
        
        .view-controls button {
            padding: 5px 10px;
            font-size: 14px;
            background-color: #3498db;
        }
    </style>
</head>
<body>
    <h1>Крестики-нолики 5 в ряд на бесконечном поле</h1>
    
    <div class="game-container">
        <div class="game-info">
            <span id="status">Ваш ход (X)</span>
        </div>
        
        <div class="view-controls">
            <button onclick="zoomOut()">-</button>
            <button onclick="resetView()">Сброс вида</button>
            <button onclick="zoomIn()">+</button>
            Масштаб: <span id="zoomLevel">100%</span>
        </div>
        
        <div class="game-board-container" id="boardContainer">
            <div id="gameBoard">
                <!-- Клетки будут добавляться динамически -->
                <div class="center-marker"></div>
            </div>
        </div>
        
        <div class="controls">
            <button id="resetBtn">Новая игра</button>
            <button id="botMoveBtn">Ход бота</button>
        </div>
        
        <div id="winMessage" class="win-message"></div>
    </div>

    <script>
        // Конфигурация игры
        const CONFIG = {
            WIN_LENGTH: 5,
            CELL_SIZE: 40,
            VISIBLE_RADIUS: 8, // Сколько клеток показывать вокруг центра
            ZOOM_LEVELS: [0.5, 0.75, 1, 1.25, 1.5, 2]
        };

        // Состояние игры
        let gameState = {
            board: {}, // { "x,y": "x" или "o" }
            currentPlayer: 'x',
            gameOver: false,
            zoomLevel: 2, // Индекс в ZOOM_LEVELS
            viewOffset: { x: 0, y: 0 }
        };

        // Элементы DOM
        const gameBoard = document.getElementById('gameBoard');
        const boardContainer = document.getElementById('boardContainer');
        const statusElement = document.getElementById('status');
        const winMessageElement = document.getElementById('winMessage');
        const resetBtn = document.getElementById('resetBtn');
        const botMoveBtn = document.getElementById('botMoveBtn');
        const zoomLevelElement = document.getElementById('zoomLevel');

        // Переменные для перетаскивания
        let isDragging = false;
        let lastMouseX, lastMouseY;

        // Инициализация игры
        function initGame() {
            gameState = {
                board: {},
                currentPlayer: 'x',
                gameOver: false,
                zoomLevel: 2,
                viewOffset: { x: 0, y: 0 }
            };
            
            winMessageElement.textContent = '';
            statusElement.textContent = 'Ваш ход (X)';
            updateZoom();
            renderBoard();
        }

        // Обновление масштаба
        function updateZoom() {
            const scale = CONFIG.ZOOM_LEVELS[gameState.zoomLevel];
            gameBoard.style.transform = `scale(${scale})`;
            zoomLevelElement.textContent = `${scale * 100}%`;
            
            // Обновляем размер контейнера для корректного скролла
            const baseSize = CONFIG.CELL_SIZE * (CONFIG.VISIBLE_RADIUS * 2 + 1);
            boardContainer.style.width = `${baseSize * scale}px`;
            boardContainer.style.height = `${baseSize * scale}px`;
        }

        function zoomIn() {
            if (gameState.zoomLevel < CONFIG.ZOOM_LEVELS.length - 1) {
                gameState.zoomLevel++;
                updateZoom();
                renderBoard();
            }
        }

        function zoomOut() {
            if (gameState.zoomLevel > 0) {
                gameState.zoomLevel--;
                updateZoom();
                renderBoard();
            }
        }

        function resetView() {
            gameState.zoomLevel = 2;
            gameState.viewOffset = { x: 0, y: 0 };
            updateZoom();
            renderBoard();
            centerView();
        }

        function centerView() {
            boardContainer.scrollLeft = boardContainer.scrollWidth / 2 - boardContainer.clientWidth / 2;
            boardContainer.scrollTop = boardContainer.scrollHeight / 2 - boardContainer.clientHeight / 2;
        }

        // Отрисовка игрового поля
        function renderBoard() {
            // Очищаем только клетки, оставляем center-marker
            const cells = gameBoard.querySelectorAll('.cell');
            cells.forEach(cell => cell.remove());
            
            const scale = CONFIG.ZOOM_LEVELS[gameState.zoomLevel];
            const scaledCellSize = CONFIG.CELL_SIZE * scale;
            
            // Определяем видимую область
            const centerX = Math.floor(gameBoard.offsetWidth / 2 / scaledCellSize) - gameState.viewOffset.x;
            const centerY = Math.floor(gameBoard.offsetHeight / 2 / scaledCellSize) - gameState.viewOffset.y;
            
            // Создаем клетки в видимой области
            for (let dx = -CONFIG.VISIBLE_RADIUS; dx <= CONFIG.VISIBLE_RADIUS; dx++) {
                for (let dy = -CONFIG.VISIBLE_RADIUS; dy <= CONFIG.VISIBLE_RADIUS; dy++) {
                    const x = centerX + dx;
                    const y = centerY + dy;
                    
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    // Позиционируем клетку
                    cell.style.left = `${(x + gameState.viewOffset.x) * CONFIG.CELL_SIZE}px`;
                    cell.style.top = `${(y + gameState.viewOffset.y) * CONFIG.CELL_SIZE}px`;
                    
                    // Отображаем содержимое клетки
                    const key = `${x},${y}`;
                    if (gameState.board[key]) {
                        cell.classList.add(gameState.board[key]);
                    }
                    
                    // Добавляем координаты
                    const coords = document.createElement('div');
                    coords.className = 'coordinates';
                    coords.textContent = `${x},${y}`;
                    cell.appendChild(coords);
                    
                    // Обработчик клика
                    cell.addEventListener('click', () => makeMove(x, y));
                    
                    gameBoard.appendChild(cell);
                }
            }
        }

        // Выполнение хода
        function makeMove(x, y) {
            if (gameState.gameOver || gameState.currentPlayer !== 'x') return;
            
            const key = `${x},${y}`;
            if (gameState.board[key]) return;
            
            gameState.board[key] = 'x';
            
            if (checkWin(x, y, 'x')) {
                gameState.gameOver = true;
                winMessageElement.textContent = 'Вы победили!';
                statusElement.textContent = 'Игра окончена';
                renderBoard();
                return;
            }
            
            if (Object.keys(gameState.board).length >= 1000) { // Защита от бесконечной игры
                gameState.gameOver = true;
                winMessageElement.textContent = 'Ничья! Слишком много ходов!';
                statusElement.textContent = 'Игра окончена';
                renderBoard();
                return;
            }
            
            gameState.currentPlayer = 'o';
            statusElement.textContent = 'Ход бота (O)...';
            
            setTimeout(makeBotMove, 500);
        }

        // Ход бота
        function makeBotMove() {
            if (gameState.gameOver) return;
            
            const move = findBestMove();
            if (move) {
                const { x, y } = move;
                const key = `${x},${y}`;
                gameState.board[key] = 'o';
                
                if (checkWin(x, y, 'o')) {
                    gameState.gameOver = true;
                    winMessageElement.textContent = 'Бот победил!';
                    statusElement.textContent = 'Игра окончена';
                    renderBoard();
                    return;
                }
                
                if (Object.keys(gameState.board).length >= 1000) {
                    gameState.gameOver = true;
                    winMessageElement.textContent = 'Ничья! Слишком много ходов!';
                    statusElement.textContent = 'Игра окончена';
                    renderBoard();
                    return;
                }
                
                gameState.currentPlayer = 'x';
                statusElement.textContent = 'Ваш ход (X)';
                renderBoard();
                
                // Прокручиваем к ходу бота
                centerOnCell(x, y);
            }
        }

        // Центрирование view на клетке
        function centerOnCell(x, y) {
            const scale = CONFIG.ZOOM_LEVELS[gameState.zoomLevel];
            const scaledCellSize = CONFIG.CELL_SIZE * scale;
            
            gameState.viewOffset.x = -x;
            gameState.viewOffset.y = -y;
            
            renderBoard();
            centerView();
        }

        // Алгоритм поиска лучшего хода для бота
        function findBestMove() {
            // Собираем все возможные ходы вокруг существующих фигур
            const candidateMoves = new Set();
            
            // Добавляем клетки вокруг всех существующих ходов
            Object.keys(gameState.board).forEach(key => {
                const [x, y] = key.split(',').map(Number);
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const newX = x + dx;
                        const newY = y + dy;
                        const newKey = `${newX},${newY}`;
                        if (!gameState.board[newKey]) {
                            candidateMoves.add(newKey);
                        }
                    }
                }
            });
            
            // Если нет кандидатов, начинаем с центра
            if (candidateMoves.size === 0) {
                candidateMoves.add('0,0');
            }
            
            let bestScore = -Infinity;
            let bestMove = null;
            
            // Проверяем выигрыш за один ход
            for (const key of candidateMoves) {
                const [x, y] = key.split(',').map(Number);
                gameState.board[key] = 'o';
                if (checkWin(x, y, 'o')) {
                    gameState.board[key] = undefined;
                    return { x, y };
                }
                gameState.board[key] = undefined;
            }
            
            // Блокируем выигрыш противника
            for (const key of candidateMoves) {
                const [x, y] = key.split(',').map(Number);
                gameState.board[key] = 'x';
                if (checkWin(x, y, 'x')) {
                    gameState.board[key] = undefined;
                    return { x, y };
                }
                gameState.board[key] = undefined;
            }
            
            // Оцениваем все кандидаты
            const movesArray = Array.from(candidateMoves);
            for (const key of movesArray) {
                const [x, y] = key.split(',').map(Number);
                const score = evaluatePosition(x, y, 'o');
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = { x, y };
                }
            }
            
            return bestMove;
        }

        // Оценка позиции
        function evaluatePosition(x, y, player) {
            let score = 0;
            const opponent = player === 'x' ? 'o' : 'x';
            
            const directions = [
                { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, 
                { dx: 1, dy: 1 }, { dx: 1, dy: -1 }
            ];
            
            for (const dir of directions) {
                let playerCount = 0;
                let opponentCount = 0;
                let emptyCount = 0;
                
                // Проверяем линию длиной WIN_LENGTH в обе стороны
                for (let i = -CONFIG.WIN_LENGTH + 1; i < CONFIG.WIN_LENGTH; i++) {
                    const checkX = x + dir.dx * i;
                    const checkY = y + dir.dy * i;
                    const key = `${checkX},${checkY}`;
                    
                    if (i >= 0 && i < CONFIG.WIN_LENGTH) {
                        if (gameState.board[key] === player) playerCount++;
                        else if (gameState.board[key] === opponent) opponentCount++;
                        else emptyCount++;
                    }
                }
                
                // Оцениваем потенциал линии
                if (playerCount === CONFIG.WIN_LENGTH - 1 && emptyCount === 1) score += 1000;
                else if (playerCount === CONFIG.WIN_LENGTH - 2 && emptyCount === 2) score += 100;
                else if (opponentCount === CONFIG.WIN_LENGTH - 1 && emptyCount === 1) score += 500;
                else if (opponentCount === CONFIG.WIN_LENGTH - 2 && emptyCount === 2) score += 50;
                else score += playerCount * 10 - opponentCount * 15;
            }
            
            // Центральные позиции ценнее
            const distanceFromCenter = Math.abs(x) + Math.abs(y);
            score += Math.max(0, 10 - distanceFromCenter);
            
            return score;
        }

        // Проверка победы
        function checkWin(x, y, player) {
            const directions = [
                { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, 
                { dx: 1, dy: 1 }, { dx: 1, dy: -1 }
            ];
            
            for (const dir of directions) {
                let count = 1;
                
                for (let i = 1; i < CONFIG.WIN_LENGTH; i++) {
                    const checkX = x + dir.dx * i;
                    const checkY = y + dir.dy * i;
                    const key = `${checkX},${checkY}`;
                    if (gameState.board[key] === player) count++;
                    else break;
                }
                
                for (let i = 1; i < CONFIG.WIN_LENGTH; i++) {
                    const checkX = x - dir.dx * i;
                    const checkY = y - dir.dy * i;
                    const key = `${checkX},${checkY}`;
                    if (gameState.board[key] === player) count++;
                    else break;
                }
                
                if (count >= CONFIG.WIN_LENGTH) return true;
            }
            
            return false;
        }

        // Обработчики событий
        resetBtn.addEventListener('click', initGame);
        botMoveBtn.addEventListener('click', () => {
            if (!gameState.gameOver && gameState.currentPlayer === 'o') {
                makeBotMove();
            }
        });

        // Перетаскивание для навигации
        boardContainer.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            boardContainer.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            gameState.viewOffset.x -= deltaX / (CONFIG.CELL_SIZE * CONFIG.ZOOM_LEVELS[gameState.zoomLevel]);
            gameState.viewOffset.y -= deltaY / (CONFIG.CELL_SIZE * CONFIG.ZOOM_LEVELS[gameState.zoomLevel]);
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            renderBoard();
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            boardContainer.style.cursor = 'default';
        });

        // Запуск игры
        window.addEventListener('load', () => {
            initGame();
            centerView();
        });

        // Предотвращаем выделение текста при перетаскивании
        document.addEventListener('selectstart', (e) => {
            if (isDragging) e.preventDefault();
        });
    </script>
</body>
</html>
